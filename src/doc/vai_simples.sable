/*Baseado no código de autoria de Natanael*/
/*Modificações feitas por Beatriz*/

Package vaiCompiler;

Helpers

	hletra = ['a' .. 'z'] | ['A' .. 'Z'] | '_';
	hdigito = ['0' .. '9'];
	hoctal_digito = ['0' .. '7'];
	hhex_digito = ['0' .. '9'] | ['A' .. 'F'] | ['a' .. 'f'];
	hdec_literal = hdigito+;
	hoct_literal = '0'(hoctal_digito)+;
	hhex_literal = '0'('x' | 'X')(hhex_digito)+;
	
	hsp = ' ';
	hht  = 0x0009;
	hlf  = 0x000a;
	hff  = 0x000c;
	hcr  = 0x000d;
	heol = hcr | hlf | hcr hlf;
	
Tokens

    twhite_space = (hsp | hht | hff | heol | 0x04)*;
	tdefault = 'default';
	tfunc = 'func';
	treturn = 'return';
	tvar = 'var';
	tboolean = 'bool';
	tint = 'int';
	tcoment_linha = '//'[32 .. 255]*;
	tcoment_bloco = '/*'[32 .. 255]*'*/';
	tint_literal = hdec_literal | hoct_literal | hhex_literal;
	tbool_literal = 'true' | 'false';
	tidentifier = hletra(hletra | hdigito)*;
	tsoma = '+';
	tmenos = '-';
	tvezes = '*';
	tdivisao = '/';
	tpar_esq = '(';
	tpar_dir = ')';
	tchave_esq = '{';
	tchave_dir = '}';
	tatribuicao = '=';
	tigual = '==';
	tmenor_q = '<';
	tmaior_q = '>';
	tand = '&&';
	tor = '||';
	tvirgula = ',';
	tponto_virgula = ';';
	 
Ignored Tokens
	tcoment_linha, tcoment_bloco, twhite_space;
	
	/*
	CORTADOS: 
	variáveis e constantes globais
	métodos
	for e if
    operadores unários	
    declarações de constantes
	tipos int diferentes
	conversão de tipos
	tipo array
	argumentos com reticências
	atribuição com definição (:=)
	função sem corpo
	statement sem ponto e vírgula no final
	statement com expressão apenas
	quebra de linha no meio do código
	statement sem efeito (vazio)
	*/
	
	/*
	FICARAM:
	Funções
	operações aritméticas e relacionais
	atribuição simples (=) -> exige declaração prévia
	declarações de variáveis dentro das funções
	*/
	
	/*
	SINTÁTICO ABSTRATO
	Simplificar árvore gerada
	*/
	
	/*SEMÂNTICO:
	checagem de tipos:
	 - expressões
	 - declaração das funções X chamada das funções 
	 - declaração de váriáveis X uso das variáveis em contexto específico
	*/
	
Productions
		
	pprogram = pfunction_decl*;
			 
	pfunction_decl = tfunc pfunction_name psignature pfunction_body;
	
	pfunction_name = tidentifier;
	
	pfunction_body = pblock;
	
	pblock = tchave_esq pstatement_list tchave_dir;
	
	pstatement_list = {statement_list} pstatement pstatement_list |
	                pstatement;		
			
	pstatement = pdeclaration | {return} preturn_stmt| {simple_stmt} psimple_stmt; 
	
	pdeclaration = {var} pvar_decl tponto_virgula;
		
	preturn_stmt = treturn pexpression_list? tponto_virgula;
	 
	psimple_stmt = {assignment} passignment tponto_virgula;		
		
	passignment = pidentifier_list tatribuicao pexpression_list;
				   
	pvar_decl = tvar pvar_spec;
	
	pvar_spec = pidentifier_list ptype|
			   {var_attr} pidentifier_list ptype tatribuicao pexpression_list;
	
	pidentifier_list = pidentifier_list tvirgula tidentifier |
					 {id} tidentifier;
		
	pexpression_list = pexpression_list tvirgula pexpression |
					  {expr} pexpression;

	pexpression = pexpression tor pexpression_a | {expr_a} pexpression_a;
	pexpression_a = pexpression_a tand pexpression_b | {expr_b} pexpression_b;
	pexpression_b = pexpression_b prel_op pexpression_c | {expr_c} pexpression_c;
	pexpression_c = pexpression_c padd_op pexpression_d | {expr_d} pexpression_d;
	pexpression_d = pexpression_d pmul_op pexpression_e | {expr_e} pexpression_e;
	pexpression_e = {uny_expr} pprimary_expr;
	
	prel_op = tigual | {menor_q} tmenor_q | {maior_q} tmaior_q;
	padd_op = tsoma | {menos} tmenos;
	pmul_op = tvezes | {divisao} tdivisao;
		
	pprimary_expr = {operando} poperand |
				   {pri_args} pprimary_expr parguments;
	
	parguments = {arg_without_param} tpar_esq tpar_dir |
				tpar_esq pexpression_list tpar_dir|
				{arg_type} tpar_esq ptype parguments_a? tpar_dir;
	parguments_a = tvirgula pexpression_list;				
	
	poperand = tidentifier | {lit} pliteral | {par_expr} ppar_expr; 
	ppar_expr = tpar_esq pexpression tpar_dir;
	
	pliteral = pbasic_literal | {func_lit} pfunction_lit;
	pbasic_literal = tint_literal | {booleano} tbool_literal;
	pfunction_lit = tfunc psignature pblock;
		 																	
	ptype = ptype_name | {par_type} ppar_type | {type_lit} ptype_lit;
	ptype_name = tboolean | {int} tint;
	ptype_lit = pfunction_type;
	
	ppar_type = tpar_esq ptype tpar_dir;

	pfunction_type = tfunc psignature;
	
	psignature = pparameters presult?;
	
	pparameters = tpar_esq tpar_dir | 
				 {par_param} tpar_esq pparameter_list tpar_dir;
	
	pparameter_list = pparameter_list tvirgula pparameter_decl |
					 {param_decl} pparameter_decl;
	
	pparameter_decl = pidentifier_list ptype;						
	
	presult = pparameters | {r_type} ptype;