/*Baseado no código de autoria de Natanael*/
/*Modificações feitas por Beatriz*/

Package vaiCompiler;

Helpers

	hletra = ['a' .. 'z'] | ['A' .. 'Z'] | '_';
	hdigito = ['0' .. '9'];
	hoctal_digito = ['0' .. '7'];
	hhex_digito = ['0' .. '9'] | ['A' .. 'F'] | ['a' .. 'f'];
	hdec_literal = hdigito+;
	hoct_literal = '0'(hoctal_digito)+;
	hhex_literal = '0'('x' | 'X')(hhex_digito)+;
	
	hsp = ' ';
	hht  = 0x0009;
	hlf  = 0x000a;
	hff  = 0x000c;
	hcr  = 0x000d;
	heol = hcr | hlf | hcr hlf;
	
Tokens

    twhite_space = (hsp | hht | hff | heol | 0x04)*;
	tdefault = 'default';
	tfunc = 'func';
	treturn = 'return';
	tvar = 'var';
	tboolean = 'bool';
	tint = 'int';
	tcoment_linha = '//'[32 .. 255]*;
	tcoment_bloco = '/*'[32 .. 255]*'*/';
	tint_literal = hdec_literal | hoct_literal | hhex_literal;
	tbool_literal = 'true' | 'false';
	tidentifier = hletra(hletra | hdigito)*;
	tsoma = '+';
	tmenos = '-';
	tvezes = '*';
	tdivisao = '/';
	tpar_esq = '(';
	tpar_dir = ')';
	tchave_esq = '{';
	tchave_dir = '}';
	tatribuicao = '=';
	tigual = '==';
	tmenor_q = '<';
	tmaior_q = '>';
	tand = '&&';
	tor = '||';
	tvirgula = ',';
	tponto_virgula = ';';
	 
Ignored Tokens
	tcoment_linha, tcoment_bloco, twhite_space;
	
	/*
	CORTADOS: 
	variáveis e constantes globais
	métodos
	for e if
    operadores unários	
    declarações de constantes
	tipos int diferentes
	conversão de tipos
	tipo array
	argumentos com reticências
	atribuição com definição (:=)
	função sem corpo
	statement sem ponto e vírgula no final
	statement com expressão apenas
	quebra de linha no meio do código
	statement sem efeito (vazio)
	*/
	
	/*
	FICARAM:
	Funções
	operações aritméticas e relacionais
	atribuição simples (=) -> exige declaração prévia
	declarações de variáveis dentro das funções
	*/
	
	/*
	SINTÁTICO ABSTRATO
	Simplificar árvore gerada
	*/
	
	/*SEMÂNTICO:
	checagem de tipos:
	 - expressões
	 - declaração das funções X chamada das funções 
	 - declaração de váriáveis X uso das variáveis em contexto específico
	*/
	
Productions
		
	program = function_decl*;
			 
	function_decl = tfunc function_name signature function_body;
	
	function_name = tidentifier;
	
	function_body = block;
	
	block = tchave_esq statement_list tchave_dir;
	
	statement_list = {statement_list} statement statement_list |
	                statement;		
			
	statement = declaration | {return} return_stmt| {simple_stmt} simple_stmt; 
	
	declaration = {var} var_decl tponto_virgula;
		
	return_stmt = treturn expression_list? tponto_virgula;
	 
	simple_stmt = {assignment} assignment tponto_virgula;		
		
	assignment = identifier_list tatribuicao expression_list;
				   
	var_decl = tvar var_spec;
	
	var_spec = identifier_list type|
			   {var_attr} identifier_list type tatribuicao expression_list;
	
	identifier_list = identifier_list tvirgula tidentifier |
					 {id} tidentifier;
		
	expression_list = expression_list tvirgula expression |
					  {expr} expression;

	expression = expression tor expression_a | {expr_a} expression_a;
	expression_a = expression_a tand expression_b | {expr_b} expression_b;
	expression_b = expression_b rel_op expression_c | {expr_c} expression_c;
	expression_c = expression_c add_op expression_d | {expr_d} expression_d;
	expression_d = expression_d mul_op expression_e | {expr_e} expression_e;
	expression_e = {uny_expr} primary_expr;
	
	rel_op = tigual | {menor_q} tmenor_q | {maior_q} tmaior_q;
	add_op = tsoma | {menos} tmenos;
	mul_op = tvezes | {divisao} tdivisao;
		
	primary_expr = {operando} operand |
				   {pri_args} primary_expr arguments;
	
	arguments = {arg_without_param} tpar_esq tpar_dir |
				tpar_esq expression_list tpar_dir|
				{arg_type} tpar_esq type arguments_a? tpar_dir;
	arguments_a = tvirgula expression_list;				
	
	operand = tidentifier | {lit} literal | {par_expr} par_expr; 
	par_expr = tpar_esq expression tpar_dir;
	
	literal = basic_literal | {func_lit} function_lit;
	basic_literal = tint_literal | {booleano} tbool_literal;
	function_lit = tfunc signature block;
		 																	
	type = type_name | {par_type} par_type | {type_lit} type_lit;
	type_name = tboolean | {int} tint;
	type_lit = function_type;
	
	par_type = tpar_esq type tpar_dir;

	function_type = tfunc signature;
	
	signature = parameters result?;
	
	parameters = tpar_esq tpar_dir | 
				 {par_param} tpar_esq parameter_list tpar_dir;
	
	parameter_list = parameter_list tvirgula parameter_decl |
					 {param_decl} parameter_decl;
	
	parameter_decl = identifier_list type;						
	
	result = parameters | {r_type} type;